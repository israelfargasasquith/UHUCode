/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "GestorJuegos.h"
#include <stdlib.h>

struct Sudoku{ //Esto no creara un sudoku nuevo si no que lo enviare al servidor
	int tablero[][];
	int solucionTablero[][];
	int nHuecos;
	Dificultad dificultad;
	int codigo;
}

void pintaSudoku(struct Sudoku* sudoku, char mensaje[]) {

	char *sDificultad;
	bool color = false;

	switch(sudoku->dificultad){
	
		case 0: sDificultad = "FACIL";
		break;

		case 1: sDificultad = "MEDIO";
		break;

		case 2: sDificultad = "DIFICIL";
		break;

		case 3: sDificultad ="EXPERTO";
		break;

		default: printf("Error de dificultad");

	}

	printf("Dificultad: %s\t\t Huecos: %d\n", sDificultad,sudoku->nHuecos);
	printf("   1 2 3   4 5 6   7 8 9\n");
    for (int i = 0; i < TAM; i++) {
		if(i % 3 == 0){	
			printf(" +-------+-------+-------+\n");
		}
		printf("%d", i+1);
        for (int j = 0; j < TAM; j++) {
			if(j % 3 == 0){
				printf("| ");
			}
			printf("%d ", sudoku->tablero[i][j]);
		
			if(j == TAM -1){
				printf("|");
			}
	    
		}

        printf("\n");
    }
	printf(" +-------+-------+-------+\n");
    printf("\n");
	printf("**Linea de avisos** : %s\n",mensaje);
	printf("1.- Juego nuevo\n");
	printf("2.- Borrar juego\n");
	printf("3.- Poner valor\n");
	printf("4.- Borrar valor\n");
	printf("5.- Ayuda\n");
	printf("6.- Salir\n");
	printf("Elige opcion: \n\n");
}

//Sobrecarga cuando no hay ningun sudoku creado
void pintaSudokuVacio(){

	printf("Dificultad: \t\t Huecos: \n");
	printf("   1 2 3   4 5 6   7 8 9\n");
    for (int i = 0; i < TAM; i++) {
	if(i % 3 == 0){	
		printf(" +-------+-------+-------+\n");
	}
	printf("%d", i+1);
        for (int j = 0; j < TAM; j++) {
		if(j % 3 == 0){
			printf("| ");
		}            
		printf("0 ");
		if(j == TAM -1){
			printf("|");
		}
	    
        }

        printf("\n");
    }
	printf(" +-------+-------+-------+\n");
    printf("\n");
	printf("**Linea de avisos**\n\n");
	printf("1.- Juego nuevo\n");
	printf("2.- -------------\n");
	printf("3.- -------------\n");
	printf("4.- -------------\n");
	printf("5.- -------------\n");
	printf("6.- Salir\n");
	printf("Elige opcion: \n\n");


}

bool menuSudokuVacio(){
	int opcMenuV = -1;
	do{
		system("clear");
		if(opcMenuV != 6  && opcMenuV != 1){
		printf("ELIGE EL NUMERO 1 O 6, POR FAVOR\n");	
	 }
		pintaSudokuVacio();	
		scanf("%d",&opcMenuV);
	}while(opcMenuV != 6 && opcMenuV != 1);

	if(opcMenuV == 6){
		return false;
	}
	return true;
}


void liberaSudokus(struct Sudoku *sudoku){
	for (int i = 0; i < TAM; i++) {
		free(sudoku->tablero[i]);
	    }
    free(sudoku->tablero);
		
	for (int i = 0; i < TAM; i++) {
		free(sudoku->solucionTablero[i]);
	    }
	free(sudoku->solucionTablero);
    free(sudoku);
}



void
gestorjuegos_1(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	TDificultad  nuevo_1_arg;
	bool_t  *result_2;
	int  borrar_1_arg;
	bool_t  *result_3;
	TFCV  ponervalor_1_arg;
	int  *result_4;
	TFC  obtenervalor_1_arg;
	bool_t  *result_5;
	TFCV  comprobarvalor_1_arg;
	int  *result_6;
	int  numerohuecos_1_arg;
	bool_t  *result_7;
	int  correcto_1_arg;
	void  *result_8;
	TFC  ayuda_1_arg;
	RCadena  *result_9;
	int  getsudoku_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, GESTORJUEGOS, GESTORJUEGOS_VER, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = nuevo_1(&nuevo_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_2 = borrar_1(&borrar_1_arg, clnt);
	if (result_2 == (bool_t *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_3 = ponervalor_1(&ponervalor_1_arg, clnt);
	if (result_3 == (bool_t *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_4 = obtenervalor_1(&obtenervalor_1_arg, clnt);
	if (result_4 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_5 = comprobarvalor_1(&comprobarvalor_1_arg, clnt);
	if (result_5 == (bool_t *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_6 = numerohuecos_1(&numerohuecos_1_arg, clnt);
	if (result_6 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_7 = correcto_1(&correcto_1_arg, clnt);
	if (result_7 == (bool_t *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_8 = ayuda_1(&ayuda_1_arg, clnt);
	if (result_8 == (void *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_9 = getsudoku_1(&getsudoku_1_arg, clnt);
	if (result_9 == (RCadena *) NULL) {
		clnt_perror (clnt, "call failed");
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	gestorjuegos_1 (host);
	bool haySudoku = false;
	int opcMenu = -1;
	char mensaje[100];
    strcpy(mensaje,"");

	do{
		if(!haySudoku){
			if(menuSudokuVacio()){
				//Pide al server un sudoku
			}else{
				exit(0);			
			}
		}
	opcMenu = -1;
		system("clear");
		if(comprobarSudoku(sudokus)){
			strcpy(mensaje,"FELICIDADES, HAS GANADO");		
		}
		pintaSudoku(sudokus,mensaje);
		strcpy(mensaje,"");
		scanf("%d",&opcMenu);
		switch(opcMenu){

			case 1:  //Crea un nuevo Sudoku y guarda los datos del actual HACER CON MEMORIA DINAMICA
					if(nSudokus == 0){ //simplemente crea uno y no guarda nada
						creaSudoku(&sudokus);	
					}/*else{ //si hay que guardar el juego
						if((ficheroDatos = fopen("ficheroSudokus.bin","ab")) == NULL){ 
							if((ficheroDatos = fopen("ficheroSudokus.bin","wb")) == NULL){
								printf("Error, no se ha podido crear el fichero con la opcion 1");
								sleep(2);
								exit(1);							
							}
							
						}
						errorFich = fwrite(&sudokus,sizeof(struct Sudoku),1,ficheroDatos);
						if(errorFich != 1){
							printf("Error,no se ha podido guardar en fichero el sudoku opc 1");
							sleep(2);
							exit(1);
						}
						fclose(ficheroDatos);
					}*/
			break;

			case 2:  //Borra el juego actual, preguntando antes
					printf("Quiere borrar la partida actual? Todo el progreso se perdera y no es revertible (S/N)\n");
						scanf(" %c",&opcBorrarActual);
					if((strcmp(&opcBorrarActual,"S") == true) || (strcmp(&opcBorrarActual,"s") == true)){
						liberaSudokus(sudokus);//,ficheroDatos);
						sudokus=NULL;
					}
			break;

			case 3: //Pone un valor en el tablero, cada vez que pone un valor comprueba (si no hay huecos libres, que esta bien el sudoku entero)
					do{
						printf("\nIntroduce el valor que quiere meter en el sudoku(1-9): ");
						scanf("%d",&ponerQuitar.pVal);
						printf("Introduce la columna a insertar el valor(1-9): ");
						scanf("%d",&ponerQuitar.pCol);
						printf("Introduce la fila a insertar el valor(1-9): ");
						scanf("%d", &ponerQuitar.pFil);
					}while(ponerQuitar.pVal > 9 || ponerQuitar.pVal < 1 || ponerQuitar.pCol > 9 || ponerQuitar.pCol < 1 || ponerQuitar.pFil > 9 || ponerQuitar.pFil < 1);
					ponerQuitar.pCol--;
					ponerQuitar.pFil--;
					if(sudokus->tablero[ponerQuitar.pFil][ponerQuitar.pCol] == 0){ //Se puede colocar el valor, si quiere reescribirlo debe borrarlo primero
						sudokus->tablero[ponerQuitar.pFil][ponerQuitar.pCol] = ponerQuitar.pVal;
						if(sudokus->nHuecos >0){
							sudokus->nHuecos--;
						}					
					}else{
						strcpy(mensaje,"Error, el valor debe ser borrado antes de introducir uno nuevo");
					}
					
			
			break;

			case 4: //Borra un valor del tablero
					
					printf("Introduce la columna a borrar el valor: ");
					scanf("%d",&ponerQuitar.pCol);
					printf("Introduce la fila a borrar el valor: ");
					scanf("%d", &ponerQuitar.pFil);
					
					if(!(ponerQuitar.pCol > 9 || ponerQuitar.pCol < 1 || ponerQuitar.pFil > 9 || ponerQuitar.pFil < 1)){
						ponerQuitar.pCol--;
						ponerQuitar.pFil--;
						if(sudokus->tablero[ponerQuitar.pFil][ponerQuitar.pCol] != 0){ //El valor vuelve a 0 si no es 0 ya
							sudokus->tablero[ponerQuitar.pFil][ponerQuitar.pCol] = 0;
								sudokus->nHuecos++;				// que no aumente el numero maximo de huecos de los dados	
						}else{
							strcpy(mensaje,"Error, el valor ya esta borrado");
						}
					}else{
						strcpy(mensaje,"ERROR: La posici√≥n indicada es erronea, por favor valores entre el 1 y el 9");
					}

			break;

			case 5: //Rellena un hueco vacio como ayuda
					;bool vacio = false;
					for(int i=0;i<TAM && !vacio;i++){
						for(int j=0;j<TAM && !vacio;j++){
							if(sudokus->tablero[i][j] == 0){
								sudokus->tablero[i][j] = sudokus->solucionTablero[i][j];
								vacio = true;
								strcpy(mensaje,"Se rellena la posicion Fila[-] Columna[-] con el Valor: -");
								mensaje[28] = (i+1)+'0';
								mensaje[39] = (j+1)+'0';
								mensaje[56] = sudokus->tablero[i][j]+ '0';
								//goto salto; todo el mundo me dice que los gotos son feos :c
							}
						}
					}				
					//salto: ;
					if(sudokus->nHuecos > 0){
						sudokus->nHuecos--;
					}
			break;

			case 6: //Sale de la app guardando el juego
					if(nSudokus > 0){
						printf("Antes de salir quiere guardar la partida actual? (S/N)\n");
						scanf(" %c",&opcGuardar);
						if((strcmp(&opcGuardar,"S") == true) || (strcmp(&opcGuardar,"s") == true)){
							/*if((ficheroDatos = fopen("ficheroSudokus.bin","ab")) == NULL){ 
								if((ficheroDatos = fopen("ficheroSudokus.bin","wb")) == NULL){
									printf("Error, no se ha podido crear el fichero con la opcion 6\n");
									exit(1);							
								}
								
							}
							errorFich = fwrite(&sudokus,sizeof(struct Sudoku),1,ficheroDatos);
							if(errorFich != 1){
								printf("Error,no se ha podido guardar en fichero el sudoku opc 6\n");
								exit(1);
							}*/
							//fclose(ficheroDatos);
						}
					}
			break;

			case 7: //carga un juego, muestra primero el numero de juegos que hay y la dificultad de cada uno YA LO HARE CUANDO IMPLEMENTE MEMORIA DINAMICA

			break;

			default:
				printf(" *******ELIJA UNA OPCION DEL 1 AL 6 POR, FAVOR*******\n");//Vuelve a preguntar por la opcion
				sleep(2);

		}

	}while(opcMenu != 6);

	

exit (0);
}
