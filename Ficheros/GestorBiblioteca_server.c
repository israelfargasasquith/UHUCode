/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "GestorBiblioteca.h"
#include <stdbool.h>
FILE *fdatos = NULL;
TLibro *Biblioteca = NULL; // Vector dinamico de libros
int numLibros = 0;         // Numero de libros almacenados en el vector
int tama = 0;           // Tamaño del vector dinamico, crece de 4 en 4 libros
int idAdmin = -1;       // Copia del idAdmin mandado al usuario
Cadena nomFichero = ""; // Copia del nombre del ultimo fichero binario cargado
int campoOrdenacion = TITULO; // Copia del ultimo campo de ordenacion realizado

Cadena contraseñaAdmin = "1234";

bool_t EsMenor(int P1, int P2, int Campo) {
    bool_t salida = FALSE;
    TLibro L1 = Biblioteca[P1];
    TLibro L2 = Biblioteca[P2];

    switch (Campo) {
    case 0:
        salida = strcmp(L1.Isbn, L2.Isbn) < 0 ? TRUE : FALSE;
        break;
    case 1:
        salida = strcmp(L1.Titulo, L2.Titulo) < 0 ? TRUE : FALSE;
        break;
    case 2:
        salida = strcmp(L1.Autor, L2.Autor) < 0 ? TRUE : FALSE;
        break;
    case 3:
        salida = L1.Anio < L2.Anio ? TRUE : FALSE;
        break;
    case 4:
        salida = strcmp(L1.Pais, L2.Pais) < 0 ? TRUE : FALSE;
        break;
    case 5:
        salida = strcmp(L1.Idioma, L2.Idioma) < 0 ? TRUE : FALSE;
        break;
    case 6:
        salida = L1.NoLibros < L2.NoLibros ? TRUE : FALSE;
        break;
    case 7:
        salida = L1.NoPrestados < L2.NoPrestados ? TRUE : FALSE;
        break;
    case 8:
        salida = L1.NoListaEspera < L2.NoListaEspera ? TRUE : FALSE;
        break;
    }
    return salida;
}

/*Se encarga de verificar la contraseña de administrador y devolverá un número
(IDA) dependiendo de las siguientes condiciones: -1: Ya hay un usuario
identificado como administrador, solo se permite uno. -2: La contraseña es
errónea. N: Un número aleatorio generado como 1+rand()%RAND_MAX Este número
deberá ser utilizado en todas las operaciones de Administración en el campo Ida.
*/
int busquedaLineal(Cadena Isbn) // Devuelve la posicion en el array
{
    int pos = -1;
    if (numLibros > 0) {
        for (int i = 0; i < numLibros; ++i) {
            if (strcmp(Biblioteca[i].Isbn, Isbn) == 0) {
                pos = i;
                goto encontrado;
            }
        }
    encontrado:
    }
    return pos;
}
void swap(TLibro *xp, TLibro *yp) {
    TLibro temp = *xp;
    *xp = *yp;
    *yp = temp;
}
void ordenar(int campo) {
    int i, j;
    bool swapped;
    for (i = 0; i < numLibros - 1; i++) {
        swapped = false;
        for (j = 0; j < numLibros - i - 1; j++) {
            if (!EsMenor(i, j, campo)) {
                swap(&Biblioteca[j], &Biblioteca[j + 1]);
                swapped = true;
            }
        }
        if (swapped == false)
            break;
    }
}

/*Se encarga de verificar la contraseña de administrador y devolverá un número
(IDA) dependiendo de las siguientes condiciones: -1: Ya hay un usuario
identificado como administrador, solo se permite uno. -2: La contraseña es
errónea. N: Un número aleatorio generado como 1+rand()%RAND_MAX Este número
deberá ser utilizado en todas las operaciones de Administración en el campo Ida.
*/
int *conexion_1_svc(char *argp, struct svc_req *rqstp) {
    static int result;
    printf("\nServidor: El valor de admin ahora mismo es de %d\n", idAdmin);
    if (idAdmin == -1) {
        printf("\nVamos a intentar iniciar sesion con la contraseña %s\n",
               argp);
        if (strcmp(argp, contraseñaAdmin) == 0) {
            idAdmin = 1 + rand() % RAND_MAX;
            printf("\nUn admin ha iniciado sesion con ID %d\n", idAdmin);
            result = idAdmin;
        } else {
            printf("\nServidor: La contraseña introducida ha sido erronea\n");
            result = -2;
        }
    } else {
        printf("\nServidor: Ya hay un admin en el sistema\n");
        result = -1;
    }

    return &result;
}
/*Comprueba que el Ida coincide con el almacenado en el servidor. Si no coincide
devuelve FALSE y caso contrario borra el Ida (lo pone a -1) almacenado en el
servidor y devuelve TRUE. */
bool_t *desconexion_1_svc(int *argp, struct svc_req *rqstp) {
    static bool_t result;

    if (idAdmin == *argp) {
        printf("\nServidor: Se desconecta el Admin de forma correcta\n");
        idAdmin = -1;
        result = true;
    } else {
        printf("\nServidor: El IdAdmin dado no es el correcto, error\n");
        result = false;
    }

    return &result;
}
/*Abre el fichero de datos cuyo nombre es pasado en el campo ‘Datos’ del tipo
TConsulta. Verificará que el Ida sea correcto (coincida con el almacenado en el
servidor y sea >0), abrirá el fichero el fichero binario y creará un vector
dinámico de Libros que llenará con el contenido del fichero y cerrará el
fichero. Si previamente hay un vector dinámico creado, lo borrará antes de
cargar los datos. Una vez cargado los datos en el vector, los ordenará por el
campo que está almacenado en el Servidor. Las salidas de este servicio son: -1:
Ya hay un usuario identificado como administrador o el Ida no coincide con el
almacenado en el Servidor. 0: No se ha cargado los datos. No ha se ha podido
abrir el fichero o bien ha habido un error de memoria dinámica. 1: Se ha cargado
correctamente los datos y se han ordenado por el campo almacenado en el
servidor. */
int *cargardatos_1_svc(TConsulta *argp, struct svc_req *rqstp) {
    static int result;

    if (argp->Ida > 0 && idAdmin == argp->Ida) {
        printf("\nIntentamos abrir el fichero %s", argp->Datos);
        fdatos = fopen(argp->Datos, "r");
        if (fdatos != NULL) // Deberia de liberar la memoria si no es null
        {
            fread(&numLibros, sizeof(int), 1, fdatos);
            if (numLibros % 4 == 0) {
                tama = numLibros;
            } else {
                tama = ((numLibros / 4) + 1) * 4;
            }
            printf("\nHay %d libros en el fichero y en el array\n", numLibros);
            Biblioteca = (TLibro *)malloc(sizeof(TLibro) * tama);
            fread(Biblioteca, sizeof(TLibro), numLibros, fdatos);
            strcpy(nomFichero, argp->Datos);
            fclose(fdatos);
            ordenar(campoOrdenacion);
            printf("\nCargado Con exito con exito\n");
            result = 1;
        } else {
            printf(
                "\nError: El nombre pasado por parametro no es un fichero\n");
            result = 0;
        }
    } else {
        printf("\nServidor error: El IdAdmin no es correcto\n");
        result = -1;
    }

    return &result;
}
/*Guarda los datos del vector dinámico en el mismo fichero que se cargó la vez
anterior. Verificará que el Ida sea correcto, y guardará todos los libros de la
biblioteca en el fichero. La salida de este servicio es TRUE si se ha guardado
correctamente los datos, FALSE en caso contrario. */
bool_t *guardardatos_1_svc(int *argp, struct svc_req *rqstp) {
    static bool_t result;

    if (*argp == idAdmin) {
        printf("\nVamos a guardar el array en el fichero %s", nomFichero);
        fdatos = fopen(nomFichero, "w");
        fwrite(&numLibros, sizeof(int), 1, fdatos);
        fwrite(Biblioteca, sizeof(TLibro) * numLibros, 1, fdatos);
        fclose(fdatos);
        printf("\n***Server: Se ha guardado el estado actual de la "
               "biblioteca.**\n");
        result = true;
    } else {
        printf("\nServidor: Error al intentar guardar el fichero, el idAdmin "
               "no es correcto\n");
        result = false;
    }

    return &result;
}
/*Guarda el libro que es pasado en el campo ‘Libro’ del tipo TNuevo en el vector
dinámico y ordenará el vector por el campo almacenado en el servidor. Verificará
que el Ida sea correcto, y que ningún libro del vector dinámico tiene el mismo
Isbn. Las salidas de este servicio son: -1: Ya hay un usuario identificado como
administrador o el Ida no coincide con el almacenado en el Servidor. 0: Hay un
libro en el vector dinámico que tiene el mismo Isbn. 1: Se ha añadido el nuevo
libro al vector dinámico. */
int *nuevolibro_1_svc(TNuevo *argp, struct svc_req *rqstp) {
    static int result;
    if (argp->Ida == idAdmin) {
        printf("\nEl nlibros %d tama es %d", numLibros, tama);
        if (busquedaLineal(argp->Libro.Isbn) == -1) {
            if (numLibros + 1 > tama) {
                tama += 4;
                printf("\nNuevo Tamaño tama %d", tama);
                Biblioteca =
                    (TLibro *)realloc(Biblioteca, sizeof(TLibro) * tama);
            }
            printf("\nMetemeos el libro %s en la posicion %d\n",
                   argp->Libro.Titulo, numLibros + 1);
            Biblioteca[numLibros++] = argp->Libro;
            printf("Libro introducido en el array %s en la posicion %d\n",
                   Biblioteca[numLibros].Titulo, numLibros);
            result = 1;
            ordenar(campoOrdenacion);
        } else {
            printf("\nError, ya hay un libro con ese isbn\n");
            result = 0;
        }
    } else {
        printf("\nError, ya hay un idAdmin o no coincide con el que esta\n");
        result = -1;
    }
    return &result;
}
/*Añadirá un número de ejemplares al libro del vector dinámico cuyo Isbn
coincida con almacenado en un campo ‘NoLibros’ del tipo TComRet. Verificará que
el Ida sea correcto y que el libro está en el vector, en cuyo caso le agregará
el número de unidades indicadas en un campo ‘NoLibros’ teniendo en cuenta que,
si hay más unidades disponibles que usuarios en espera, todos estos usuarios
recibirán un libro reduciendo la cantidad de libros disponibles, y si hay menos
libros disponibles que usuarios en espera, se reducirá dicho usuarios en espera
en la misma cantidad que libros disponibles. Una vez actualizado el libro se
ordenarán todos los libros del vector dinámica por el campo almacenado en el
servidor. Las salidas de este servicio son: -1: Ya hay un usuario identificado
como administrador o el Ida no coincide con el almacenado en el Servidor. 0: No
hay un libro en el vector dinámico que tiene el mismo Isbn. 1: Se han agregado
los nuevos ejemplares del libro y los datos están ordenados. */
int *comprar_1_svc(TComRet *argp, struct svc_req *rqstp) {
    static int result;

    if (idAdmin != -1) {
        int pos = busquedaLineal(argp->Isbn);
        if (pos != -1) {
            if (Biblioteca[pos].NoListaEspera > 0) {
                int diff = argp->NoLibros - Biblioteca[pos].NoListaEspera;
                if (diff >= 0) {
                    Biblioteca[pos].NoListaEspera = 0;
                    Biblioteca[pos].NoLibros += diff;
                } else {
                    Biblioteca[pos].NoListaEspera = -diff;
                }
            } else {
                Biblioteca[pos].NoLibros += argp->NoLibros;
            }
            printf("\nTodo bien\n");
            result = 1;
        } else {
            printf("\nNo se ha encontrado el libro en el vector\n");
            result = 0;
        }
    } else {
        printf("\nYa hay un admin %d o su ida no coincide con el pasado %d\n",
               idAdmin, argp->Ida);
        result = -1;
    }

    return &result;
}
/*Eliminará un número de ejemplares al libro del vector dinámico cuyo Isbn
coincida con indicado en el campo ‘NoLibros’ del tipo TComRet. Verificará que el
Ida sea correcto y que el libro está en el vector, en cuyo caso le restará el
número de unidades especificadas en el campo ‘NoLibros’ siempre y cuando haya
suficientes. Una vez actualizado el libro, se ordenará el vector dinámico por el
campo almacenado en el servidor. Las salidas de este servicio son: -1: Ya hay un
usuario identificado como administrador o el Ida no coincide con el almacenado
en el Servidor. 0: No hay un libro en el vector dinámico que tiene el mismo
Isbn. 1: Se han reducido el número de ejemplares disponibles y se han ordenado
los datos. 2: No hay suficientes ejemplares disponibles para ser retirados. */
int *retirar_1_svc(TComRet *argp, struct svc_req *rqstp) {
    static int result;

    if (argp->Ida == idAdmin) {
        int pos = busquedaLineal(argp->Isbn);
        // printf("\nLa posicion devuelta es %d", pos);
        // getchar();
        if (pos != -1) {
            if (Biblioteca[pos].NoLibros >= argp->NoLibros) {
                Biblioteca[pos].NoLibros -= argp->NoLibros;
                printf("\nTodo correcto\n");
                result = 1;
            } else {
                printf("\nNo hay suficientes libros para borrar\n");
                result = 2;
            }
        } else {
            printf("\nNo existe libro con tal ISBN\n");
            result = 0;
        }

    } else {
        printf("\nIdAdmin incorrecto o ya esta de alta\n");
        result = -1;
    }

    return &result;
}
/*Realizará una ordenación de los libros almacenados en el vector dinámica por
el campo ‘Campo’ del tipo TOrdenacion. Verificará que el Ida sea correcto y que
el vector dinámico tiene libros antes de la ordenación. Una vez terminado el
campo ‘Campo’ será guardado en el servidor para futuras ordenaciones. Las
salidas de este servicio son:
FALSE: Ya hay un usuario identificado como administrador o el Ida no coincide
con el almacenado en Servidor. TRUE: Se ha Ordenado correctamente el vector. */
bool_t *ordenar_1_svc(TOrdenacion *argp, struct svc_req *rqstp) {
    static bool_t result;
    if (argp->Ida == idAdmin) {
        TLibro tmp;
        campoOrdenacion = argp->Campo;
        ordenar(campoOrdenacion);
        result = TRUE;
    } else {
        printf("\nError: Ya hay un admin de alta");
        result = FALSE;
    }
    return &result;
}
/*Devuelve siempre el número de libros del vector dinámico. No hay que verificar
el Ida pasado por parámetro. */
int *nlibros_1_svc(int *argp, struct svc_req *rqstp) {
    static int result;
    result = numLibros;
    return &result;
}
/*Devuelve la posición del Libro cuya Isbn coincide con el almacenado en el
campo ‘Datos’ del tipo TConsulta. Verificará que el Ida es correcto. Las salidas
de este servicio son:
-2: Ya hay un usuario identificado como administrador o el
Ida no coincide con el almacenado en Servidor.
 -1: No se ha encontrado ningún
Libro con el Isbn indicado en el campo ‘Datos’.
>=0: La posición del libro dentro de vector dinámico que contiene el mismo Isbn
que el indicado en el campo ‘Datos’. */
int *buscar_1_svc(TConsulta *argp, struct svc_req *rqstp) {
    static int result;

    if (argp->Ida == idAdmin) {
        result = busquedaLineal(argp->Datos);
    } else {
        result = -2;
    }

    return &result;
}
VER COMO BUSCAR POR PALABRAS CON STRSTR Y COMO ORDENAR CON ESE FILTRO
    /*Devuelve el libro cuya posición es indicada en el campo ‘Pos’
         del tipo TPosicion.En el caso que la posición sea incorrecta devuelve
       un libro con los campos de texto puestos a “????” y los numéricos a 0. Si
       el Ida no es correcto pondrá a 0 los campos ‘NoPresentados’ y
       ‘NoListaEspera’ del Libro a devolver.*/
    TLibro *
    descargar_1_svc(TPosicion *argp, struct svc_req *rqstp) {
    static TLibro result;
    TLibro tmp;
    if (argp->Pos < numLibros) {
        if (argp->Ida == idAdmin) {
            result = Biblioteca[argp->Pos];
        } else {
            result = Biblioteca[argp->Pos];
            result.NoListaEspera = 0;
            result.NoPrestados = 0;
            result.NoLibros = 0;
        }
    } else {
        printf("\nPosicion indicada erronea\n");
        tmp.Anio = -1;
        strcpy(tmp.Autor, "????");
        result = tmp;
    }
    return &result;
}
/*Presta a un usuario de la biblioteca un libro cuya posición es indicada en el
campo ‘Pos’ del tipo TPosicion, de manera que si hay ejemplares disponibles se
reducirán en una unidad y los prestados aumentarán en una unidad. Si no hubiera
ejemplares disponibles se aumentará el número de usuarios en la lista de espera.
Una vez actualizado el libro se ordenará el vector dinámicos por el campo
almacenado en el servidor. Las salidas de este servicio son: -1: La posición
indicada no está dentro de los límites del vector dinámico. 1: Se ha prestado el
libro el libro correctamente. 0: Se ha puesto el usuario en la lista de espera.
*/
int *prestar_1_svc(TPosicion *argp, struct svc_req *rqstp) {
    static int result;

    if (argp->Pos <= numLibros && numLibros > 0) {
        if (Biblioteca[argp->Pos].NoLibros > 0) {
            Biblioteca[argp->Pos].NoPrestados++;
            Biblioteca[argp->Pos].NoLibros--;
            result = 1;
        } else {
            Biblioteca[argp->Pos].NoListaEspera++;
            printf("\nNo hay libros disponibles, se pone en lista de espera\n");
            result = 0;
        }
        ordenar(campoOrdenacion);
    } else {
        printf("\nError estas buscando una posicion imposible\n");
        result = -1;
    }

    return &result;
}
/*Devuelve un ejemplar del libro cuya posición es indicada en el campo ‘Pos’ del
tipo TPosicion, de manera que si hay usuarios en espera, se reducirán en uno
unidad y se aumentarán en una unidad el número de libros prestados. Si no hay
usuario en espera, pero si libros prestados, se reducirá el número de libros
`restados y se aumentará el número de libros disponibles. Una vez actualizado el
libro, se ordenará el vector dinámico por el campo almacenado en el servidor.
Las salidas de este servicio son: -1: La posición indicada no está dentro de los
límites del vector dinámico. 0: Se ha devuelto el libro reduciendo el número de
usuarios en espera. 1: Se ha devuelto aumentando el número de libros
disponibles. 2: El libro no se puede devolver, porque no hay ni usuarios en
lista de espera ni libros prestados. */
int *devolver_1_svc(TPosicion *argp, struct svc_req *rqstp) {
    static int result;
    if (argp->Pos <= numLibros && numLibros > 0) {
        if (Biblioteca[argp->Pos].NoListaEspera == 0) {
            Biblioteca[argp->Pos].NoLibros++;
            result = 1;
        } else {
            Biblioteca[argp->Pos].NoListaEspera--;
            printf("\nSe reduce el numero de gente en espera\n");
            result = 0;
        }
        ordenar(campoOrdenacion);
    } else {
        printf("\nError estas buscando una posicion imposible\n");
        result = -1;
    }

    return &result;
}