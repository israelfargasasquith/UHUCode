/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "GestorBiblioteca.h"
#include <stdbool.h>
FILE *fdatos = NULL;
TLibro *Biblioteca = NULL; // Vector dinamico de libros
int numLibros = 0;		   // Numero de libros almacenados en el vector
int tama = 0;			   // Tamaño del vector dinamico, crece de 4 en 4 libros
int idAdmin = -1;		   // Copia del idAdmin mandado al usuario
Cadena nomFichero = "";	   // Copia del nombre del ultimo fichero binario cargado
int campoOrdenacion = 0;   // Copia del ultimo campo de ordenacion realizado

Cadena contraseñaAdmin = "1234";

bool_t EsMenor(int P1, int P2, int Campo)
{
	bool_t salida = FALSE;
	TLibro L1 = Biblioteca[P1];
	TLibro L2 = Biblioteca[P2];

	switch (Campo)
	{
	case 0:
		salida = strcmp(L1.Isbn, L2.Isbn) < 0 ? TRUE : FALSE;
		break;
	case 1:
		salida = strcmp(L1.Titulo, L2.Titulo) < 0 ? TRUE : FALSE;
		break;
	case 2:
		salida = strcmp(L1.Autor, L2.Autor) < 0 ? TRUE : FALSE;
		break;
	case 3:
		salida = L1.Anio < L2.Anio ? TRUE : FALSE;
		break;
	case 4:
		salida = strcmp(L1.Pais, L2.Pais) < 0 ? TRUE : FALSE;
		break;
	case 5:
		salida = strcmp(L1.Idioma, L2.Idioma) < 0 ? TRUE : FALSE;
		break;
	case 6:
		salida = L1.NoLibros < L2.NoLibros ? TRUE : FALSE;
		break;
	case 7:
		salida = L1.NoPrestados < L2.NoPrestados ? TRUE : FALSE;
		break;
	case 8:
		salida = L1.NoListaEspera < L2.NoListaEspera ? TRUE : FALSE;
		break;
	}
	return salida;
}

/*Se encarga de verificar la contraseña de administrador y devolverá un número (IDA) dependiendo de las
siguientes condiciones:
-1: Ya hay un usuario identificado como administrador, solo se permite uno.
-2: La contraseña es errónea.
N: Un número aleatorio generado como 1+rand()%RAND_MAX
Este número deberá ser utilizado en todas las operaciones de Administración en el campo Ida. */

int busquedaLineal(Cadena Isbn)
{
	if (numLibros > 0)
	{
	}
}
QUE COJONES EL ID ADMIN EN BUSCAR NO SE COMPARA BIEN?

int *conexion_1_svc(char *argp, struct svc_req *rqstp)
{
	static int result;
	printf("\nServidor: El valor de admin ahora mismo es de %d", idAdmin);
	if (idAdmin == -1)
	{
		printf("\nVamos a intentar iniciar sesion con la contraseña %s", argp);
		if (strcmp(argp, contraseñaAdmin) == 0)
		{
			idAdmin = 1 + rand() % RAND_MAX;
			printf("\nUn admin ha iniciado sesion con ID %d", idAdmin);
			result = idAdmin;
		}
		else
		{
			printf("\nServidor: La contraseña introducida ha sido erronea");
			result = -2;
		}
	}
	else
	{
		printf("\nServidor: Ya hay un admin en el sistema");
		result = -1;
	}

	return &result;
}
/*Comprueba que el Ida coincide con el almacenado en el servidor. Si no coincide devuelve FALSE y caso
contrario borra el Ida (lo pone a -1) almacenado en el servidor y devuelve TRUE. */
bool_t *
desconexion_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;

	if (idAdmin == *argp)
	{
		printf("\nServidor: Se desconecta el Admin de forma correcta");
		result = true;
	}
	else
	{
		printf("\nServidor: El IdAdmin dado no es el correcto, error");
		result = false;
	}

	return &result;
}

int *cargardatos_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	static int result;

	if (argp->Ida > 0 && idAdmin == argp->Ida)
	{
		printf("\nIntentamos abrir el fichero %s", argp->Datos);
		fdatos = fopen(argp->Datos, "r");
		if (fdatos != NULL) // Deberia de liberar la memoria si no es null
		{
			fread(&numLibros, sizeof(int), 1, fdatos);
			if (numLibros % 4 == 0)
			{
				tama = numLibros;
			}
			else
			{
				tama = ((numLibros / 4) + 1) * 4;
			}
			printf("\nHay %d libros en el fichero y en el array", numLibros);
			Biblioteca = (TLibro *)malloc(sizeof(TLibro) * tama);
			fread(Biblioteca, sizeof(TLibro), numLibros, fdatos);
			strcpy(nomFichero, argp->Datos);
			fclose(fdatos);
			// falta ordenarlos
			printf("\nCargado Con exito con exito");
			result = 1;
		}
		else
		{
			printf("\nError: El nombre pasado por parametro no es un fichero");
			result = 0;
		}
	}
	else
	{
		printf("\nServidor error: El IdAdmin no es correcto");
		result = -1;
	}

	return &result;
}

bool_t *
guardardatos_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;

	if (*argp == idAdmin)
	{
		printf("\nVamos a guardar el array en el fichero %s", nomFichero);
		fdatos = fopen(nomFichero, "w");
		fwrite(&numLibros, sizeof(int), 1, fdatos);
		fwrite(Biblioteca, sizeof(TLibro) * numLibros, 1, fdatos);
		fclose(fdatos);
		printf("\n***Server: Se ha guardado el estado actual de la biblioteca.**");
		printf("\nSe debe haber guardado bien... Comprueba");
		result = true;
	}
	else
	{
		printf("\nServidor: Error al intentar guardar el fichero, el idAdmin no es correcto");
		result = false;
	}

	return &result;
}

int *nuevolibro_1_svc(TNuevo *argp, struct svc_req *rqstp)
{
	static int result;

	return &result;
}

int *comprar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *retirar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

bool_t *
ordenar_1_svc(TOrdenacion *argp, struct svc_req *rqstp)
{
	static bool_t result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *nlibros_1_svc(int *argp, struct svc_req *rqstp)
{
	static int result;
	result = numLibros;
	return &result;
}

int *buscar_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

TLibro *
descargar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static TLibro result;
	TLibro tmp;
	printf("\nEnviamos libro %d, al idAdmin %d, el nuestro es %d", argp->Pos, argp->Ida, idAdmin);
	if (idAdmin == argp->Pos)
		printf("verdad");
	else
		printf("mentira");
	if (argp->Pos < numLibros)
	{
		printf("\nNum libros %d posicion en la biblioteca %d", numLibros, argp->Pos);
		printf("\nEl solicitado es %s", Biblioteca[argp->Pos].Titulo);
		if (argp->Ida == idAdmin)
		{
			result = Biblioteca[argp->Pos];
			printf("\nEnviamos %s", result.Titulo);
			/*result.Anio = Biblioteca[argp->Pos].Anio;
			strcpy(result.Autor, Biblioteca[argp->Pos].Autor);
			strcpy(result.Idioma, Biblioteca[argp->Pos].Idioma);
			strcpy(result.Isbn, Biblioteca[argp->Pos].Isbn);
			result.NoLibros = Biblioteca[argp->Pos].NoLibros;
			result.NoListaEspera = Biblioteca[argp->Pos].NoListaEspera;
			result.NoPrestados = Biblioteca[argp->Pos].NoPrestados;
			strcpy(result.Pais, Biblioteca[argp->Pos].Pais);
			strcpy(result.Titulo, Biblioteca[argp->Pos].Titulo);*/
		}
		else
		{ // enviamos sin indicar prestados
			printf("\nPor hacer");
		}
	}
	else
	{
		printf("\nPosicion indicada erronea");
		tmp.Anio = 0;
		strcpy(tmp.Autor, "????");
		result = tmp;
	}
	return &result;
}

int *prestar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *devolver_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	/*
	 * insert server code here
	 */

	return &result;
}